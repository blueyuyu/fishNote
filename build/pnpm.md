### pnpm 相较于 npm 、 yarn 的优点

npm 缺点： 路径过长，磁盘空间浪费、安装速度慢

因为包的嵌套结构，会导致系统路径过长；

多个包安装相同依赖，导致大量资源被浪费；

且多次安装相同的包，导致安装速度慢；

#### yarn

扁平化所有的依赖包，减少目录深度，把所有依赖包都放在 node_modules 下，减少了一些循环嵌套的现象。

缺点: 当多个项目包需要同一个库的不同版本时，还是需要分别引入这个库的不同版本；

幽灵依赖： 未在 package.json 里面定义，但是项目里面可以引入，因为依赖的依赖也被拍平在 node

#### pnpm

pnpm 通过**「全局存储和符号链接机制」**从根源上解决了依赖重复安装和路径长度问题。

所有的包文件都安装在用户的全局目录下，这个全局存储目录是 pnpm 用于存储所有已安装包的文件的地方，它位于用户的主目录下，例如 `~/.pnpm-store/v3/files`。

即使 pnpm 在全局存储目录中只存储了包的内容，项目中的 `node_modules` 目录中仍然会有实际的文件。这是因为 pnpm 使用符号链接将这些文件链接到全局存储目录中的实际文件。

顶层 `node_modules` 下有 `.pnpm` 目录以打平结构管理每个版本包的源码内容，以硬链接方式指向 pnpm-store 中的文件地址。

每个项目 `node_modules` 下安装的包以软链接方式将内容指向 `node_modules/.pnpm` 中的包。所以每个包的寻找都要经过三层结构：`node_modules/package-a` > 软链接 `node_modules/.pnpm/package-a@1.0.0/node_modules/package-a` > 硬链接 `~/.pnpm-store/v3/files/00/xxxxxx`。

硬链接是指向磁盘上原始文件所在的同一位置 （直接指向相同的数据块）

软连接可以理解为新建一个文件，它包含一个指向另一个文件或目录的路径 （指向目标路径）

.pnpm 文件里面有装在全局的全部文件，某个库的所有版本，引入软链接， 更加方便用户理解的同时，方便查看包，保持包的结构一致。

**「npm2 的嵌套结构」**：每个依赖项都会有自己的 `node_modules` 目录，导致了依赖被重复安装，严重浪费了磁盘空间 💣；在依赖层级比较深的项目中，甚至会超出 windows 系统的文件路径长度 💣

**「npm3+ 和 Yarn 的扁平化策略：」** 尽量将所有依赖包安装在项目的顶层 `node_modules` 目录下，解决了 `npm2` 嵌套依赖的问题。但是该方案有一个重大缺陷就是“幽灵依赖”💣；而且依赖包有多个版本时，只会提升一个，那其余版本依然会被重复安装，还是有浪费磁盘空间的问题 💣

**「pnpm 全局存储和符号链接机制：」** 结合软硬链和三层寻址，解决了依赖被重复安装的问题，更加变态的是，同一盘符下的不同项目都可以共用一个全局 `pnpm store`。节省了磁盘空间，并且根本不存在“幽灵依赖”，安装速度还贼快 💪💪💪

##### 🔧 2. 构建系统深入解析

- Webpack 构建机制与优化技巧
- 自定义 Loader/Plugin 开发
- 构建速度与体积双优化实践

##### ⚙️ 3. 编译原理与兼容性处理

- Babel 编译机制详解
- 编写自定义 Babel 插件，掌握 AST 核心

##### 🔄 4. 自动化工作流与 CI/CD

- GitHub Actions 全流程部署
- 多环境自动发布与持续集成实战

##### 🚀 5. SEO 与性能优化实战

- 搜索引擎友好页面构建（SSR + Meta 管理）
- Web Vitals 性能指标优化与真实用户监控

## CI CD 学习使用
