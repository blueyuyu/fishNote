## 前端项目中可以研究的

1. pipline 工作流任务，可以研究；
2. 大屏的兼容处理是怎么做的，像素点级别的
3. 大文件上传的解决
4. 项目中文件的预览怎么做的？模型仓库对代码文件的预览；
5. 前端如何实现工作流；
6. 如何创建容器，nginx, 如何2配置代理；
7. 完成一个小模型的demo；

## 小模型

小模型是啥

小模型通常指参数规模相对较小、计算资源需求较低的机器学习或深度学习模型。

### （二）小模型类型

1. **传统机器学习模型**
   * **决策树**：结构简单，易于理解和解释，计算量小。常用于分类和回归问题，如预测客户是否流失、房价预测等。
   * **随机森林**：由多个决策树组成的集成模型，通过投票或平均等方式进行预测，具有较好的稳定性和泛化能力，对噪声数据和缺失值有一定的鲁棒性。
   * **支持向量机（SVM）**：在小样本数据集上表现出色，能够有效处理高维数据，常用于文本分类、图像识别等领域。
2. **轻量级深度学习模型**
   * **MobileNet**：专为移动设备和嵌入式设备设计的卷积神经网络（CNN），通过深度可分离卷积等技术大幅减少模型参数和计算量，同时保持较好的图像分类性能。
   * **ShuffleNet**：采用通道洗牌操作来提高信息流通效率，在保持高精度的同时降低计算复杂度，适用于对计算资源和功耗要求较高的场景。
   * **EfficientNet**：通过对模型的深度、宽度和分辨率进行联合优化，在不同的资源约束下都能实现高效的性能，具有较好的扩展性。

### （三）部署平台与框架

1. **移动端**
   * **TensorFlow Lite**：由 Google 开发，专为移动和嵌入式设备优化的深度学习框架。它支持多种模型格式转换，提供量化工具以进一步减小模型大小和计算量，同时具备跨平台能力，可在 Android 和 iOS 设备上运行。
   * **Core ML**：苹果公司推出的机器学习框架，深度集成于 iOS、iPadOS、macOS 和 watchOS 等操作系统，对苹果设备的硬件和软件环境有良好的优化，支持多种模型类型导入，性能表现出色。
2. **嵌入式设备**
   * **OpenCV**：一个广泛使用的计算机视觉库，包含了许多传统机器学习和计算机视觉算法的实现，支持在嵌入式设备上进行图像和视频处理任务，如目标检测、特征提取等。
   * **NCNN**：腾讯开源的轻量级神经网络推理框架，具有高度优化的 CPU 计算内核，支持多种深度学习模型，在 ARM 架构设备上性能卓越，常用于嵌入式视觉应用。
3. **云端与服务器端**
   * **Flask**：一个轻量级的 Python Web 框架，可用于快速搭建模型服务接口。通过将训练好的小模型封装在 Flask 应用中，可以方便地通过 HTTP 协议对外提供推理服务。
   * **Django**：功能强大的 Python Web 框架，适用于构建大型、复杂的模型服务系统，提供了丰富的功能，如数据库管理、用户认证等，可用于搭建企业级的模型部署平台。

### （四）性能评估指标

1. **推理速度**
   衡量模型从输入数据到输出结果所需的时间，通常以每秒处理的样本数（FPS）或单个样本的推理时间（如毫秒 / 样本）来表示。推理速度直接影响模型在实时应用场景中的可用性。
2. **模型大小**
   指模型文件占用的存储空间大小，较小的模型大小不仅便于存储和传输，也有利于在资源受限的设备上部署。
3. **准确率**
   对于分类模型，准确率是指正确预测的样本数占总样本数的比例；对于回归模型，常用均方误差（MSE）、平均绝对误差（MAE）等指标来衡量预测值与真实值之间的差异程度。准确率是评估模型性能的重要指标，但在实际应用中，还需结合其他指标综合考虑。
4. **资源利用率**
   包括 CPU 使用率、内存占用、功耗等指标，反映模型在运行过程中对设备资源的消耗情况。在资源受限的环境中，低资源利用率对于模型的稳定运行至关重要。

## K8S

Kubernetes（k8s）是一个开源的容器编排系统，旨在自动化容器化应用的部署、扩展和管理，以下从其起源、核心功能、架构等方面详细介绍：

### 起源与发展

* Kubernetes 最初由谷歌公司开发，于 2014 年开源。它借鉴了谷歌内部大规模容器管理的经验，旨在为容器化应用提供一个高效、可靠的管理平台。自开源以来，Kubernetes 得到了社区的广泛支持和贡献，成为了容器编排领域的事实上的标准，被众多企业和组织广泛应用于生产环境中。

### 核心功能

* **容器部署与管理**：用户可以通过简单的配置文件，如 YAML 或 JSON，定义应用所需的容器、容器的镜像、资源需求等信息，Kubernetes 会根据这些定义自动在集群中的节点上启动和运行容器，确保应用按照预期的方式部署。
* **自动扩缩容**：Kubernetes 可以根据应用的负载情况，自动调整容器的数量。例如，当应用的流量增加时，Kubernetes 可以自动创建更多的容器来处理请求；当流量减少时，又可以自动删除多余的容器，以实现资源的高效利用。
* **服务发现与负载均衡**：Kubernetes 为容器化应用提供了服务发现和负载均衡的功能。它可以为一组具有相同功能的容器创建一个服务，其他应用可以通过这个服务的名称来访问这些容器，Kubernetes 会自动将请求负载均衡到各个容器上。
* **存储管理**：支持多种存储类型，如本地存储、网络存储等，并提供了存储卷的概念，允许容器挂载存储卷来持久化数据，确保数据在容器重启或迁移时不会丢失。
* **自动故障恢复**：实时监控容器和节点的状态，当发现容器或节点出现故障时，会自动进行重启或重新调度，确保应用的高可用性。

### 架构组成

* **控制平面（Control Plane）**：由多个组件组成，包括 kube-apiserver、kube-controller-manager、kube-scheduler 等，负责管理和控制整个集群的运行，如处理用户的请求、调度容器、管理资源等。
* **数据平面（Data Plane）**：也称为节点（Node），是集群中的工作机器，可以是物理机或虚拟机。每个节点上运行着 kubelet、kube-proxy 等组件，负责运行容器、与控制平面通信等。

### 应用场景

* **微服务架构**：在微服务架构中，一个应用通常由多个相互独立的微服务组成，每个微服务可以独立部署和扩展。Kubernetes 非常适合管理这种微服务架构的应用，它可以为每个微服务创建独立的容器，并进行统一的管理和调度。
* **持续集成与持续部署（CI/CD）**：与 CI/CD 工具集成，实现应用的自动化构建、测试和部署。在 CI/CD 流程中，当代码提交后，Kubernetes 可以自动拉取最新的代码，构建容器镜像，并将新的版本部署到集群中。
* **云原生应用开发**：云原生应用通常具有分布式、弹性、可扩展等特点，Kubernetes 提供了一系列的功能和工具，如服务发现、负载均衡、自动扩缩容等，非常适合开发和运行云原生应用。

## 容器镜像

* **定义**：容器镜像是一个包含了运行容器所需的所有内容的只读模板，包括操作系统、应用程序、库文件、配置文件等。它类似于虚拟机的镜像，但更轻量级，只包含运行特定应用或服务所需的最小环境。可以将容器镜像看作是一个 “打包好的盒子”，里面装着运行某个软件所需的一切，无论在任何环境中，只要有容器运行时，都可以基于这个镜像快速创建出一个运行该软件的容器。
* **作用**
  * **可移植性**：容器镜像可以在不同的操作系统和硬件环境中运行，只要目标环境支持容器技术。这使得开发人员可以在自己的开发环境中构建镜像，然后在测试环境、生产环境等不同环境中轻松部署，确保应用在各个环境中的运行状态一致。
  * **版本管理**：可以为不同版本的应用创建不同的镜像版本，方便进行版本控制和回滚操作。例如，当应用进行升级时，可以创建一个新的镜像版本，如果新版本出现问题，可以快速回滚到之前的镜像版本。
  * **共享与分发**：容器镜像可以存储在镜像仓库中，方便团队成员之间共享，也可以在不同的集群或数据中心之间进行分发。这样，多个团队或项目可以复用同一个镜像，提高了开发和部署的效率。

## 集群

* **定义**：在容器领域，集群是指由多个节点（物理机或虚拟机）组成的一个集合，这些节点通过网络相互连接，共同协作来运行和管理容器化应用。集群中的节点可以分为控制平面节点和工作节点。控制平面节点负责管理和协调整个集群的运行，如调度容器、管理资源等；工作节点则负责运行容器化的应用程序。
* **作用**
  * **高可用性**：通过将应用部署到多个节点上，当某个节点出现故障时，其他节点可以继续提供服务，保证应用的连续性。例如，一个 Web 应用部署在一个包含多个节点的集群中，当其中一个节点因硬件故障停机时，Kubernetes 会自动将该节点上的容器调度到其他健康的节点上运行，用户几乎不会察觉到服务的中断。
  * **可扩展性**：可以根据业务需求方便地添加或删除节点，实现集群规模的灵活扩展或收缩。当业务流量增加时，向集群中添加更多的节点，以提高集群的处理能力；当业务流量减少时，可以删除一些多余的节点，降低成本。
  * **资源高效利用**：集群可以对资源进行统一管理和调度，根据各个容器的资源需求，将其分配到合适的节点上，使资源得到充分利用。例如，一些对 CPU 要求较高的容器可以被调度到 CPU 资源丰富的节点上，而对内存要求较高的容器则可以被分配到内存充足的节点上。

## 裸金属

裸金属（Bare Metal）在信息技术领域是指没有经过虚拟化等软件层抽象，直接使用物理硬件来提供计算、存储和网络等资源的服务器或计算设备。适用： 适用于对安全性，稳定性，性能等要求高的软件领域。

### 特点

* **高性能**：由于没有虚拟化层的开销，裸金属服务器的计算、存储和网络等硬件资源可以被应用程序直接访问和使用，能充分发挥硬件的性能潜力，为对性能要求极高的应用，如高性能计算（HPC）、金融交易系统、大型数据库等提供强大的计算动力。
* **低延迟**：数据在硬件层面的传输和处理无需经过虚拟化层的转换和调度，大大减少了数据传输和处理的中间环节，从而能够实现极低的延迟，适用于对实时性要求极高的场景，如自动驾驶、工业自动化控制、高频金融交易等。
* **高稳定性**：裸金属服务器的硬件和软件环境相对简单和直接，没有复杂的虚拟化软件层可能带来的兼容性问题和故障点，具有更高的稳定性和可靠性，适合运行关键任务和核心业务应用，如企业的核心数据库、电子商务网站的后台系统等。
* **安全隔离性好**：每台裸金属服务器都是独立的物理设备，不同用户或不同应用之间在硬件层面实现了完全的隔离，有效防止了数据泄露和恶意攻击，满足对数据安全性和隐私性要求极高的行业需求，如政府、金融、医疗等领域。

### 应用场景

* **高性能计算领域**：在科研机构、气象部门、石油勘探等进行大规模科学计算和数据处理的场景中，裸金属服务器能够提供强大的计算能力，支持复杂的科学模型计算、气象数据模拟、地质数据处理等工作。
* **对安全和合规要求极高的行业**：金融机构处理大量敏感的客户资金和交易数据，政府部门涉及国家机密和重要政务信息，医疗行业存储患者的个人健康数据等，这些行业对数据安全和合规性有严格要求，裸金属服务器的物理隔离特性能够更好地满足安全需求。
* **大型数据库应用**：像一些大型企业的核心业务数据库，如电信运营商的用户数据管理系统、大型电商平台的订单和库存管理数据库等，需要处理海量的数据和高并发的读写请求，裸金属服务器的高性能和低延迟可以确保数据库的高效运行。
* **特殊硬件需求场景**：某些应用需要使用特定的硬件设备或接口，如工业控制中的专用传感器接口、视频编辑中的专业图形处理卡等，裸金属服务器可以直接连接和使用这些特殊硬件，满足应用的特殊需求。

#### 裸金属与小模型的关系

## 用户分析

这份负载数据主要用于记录和上报用户在网页端与应用交互的相关事件信息，可能用于分析用户行为、优化产品、统计数据等，具体如下：

1. **事件信息**

   * **事件类型**：`event`为`read_message`，表明该事件与读取消息相关。
   * **详细参数**：`params`字段包含丰富信息，如环境信息（`env`为`PROD`代表生产环境，`region`为`cn`代表中国地区）、版本信息（`scmVersion`为`1.0.1.5481`）、页面信息（`landing_page_url`为用户进入应用的着陆页 URL，`current_page`为当前页面`chat` ，`previous_page`为上一页面`other`） 、消息相关信息（`message_id` 、`conversation_id` 、`reply_id`等） 以及事件相关时间和操作信息（`read_duration`阅读时长、`show_duration`展示时长 、`start_method`和`end_method`开始与结束操作方式）。
2. **用户信息**

   * **标识**：`user_unique_id` 、`user_id` 、`web_id`用于标识用户，`user_is_login`表明用户已登录。
3. **设备与环境信息**

   * **操作系统**：`os_name`为`windows`，`os_version`为`10`。
   * **浏览器**：`browser`为`Chrome`，`browser_version`为`131.0.0.0`。
   * **分辨率**：`resolution`为`1920x1080`。
   * **来源**：`utm_source`为`bing_sem`，表明流量来源是必应搜索引擎营销。
4. **上报目的**

   * **用户行为分析**：通过记录消息阅读的相关时间、操作方式等，分析用户对消息的关注度、停留时间等，以优化消息展示方式和内容策略。
   * **产品优化**：结合页面信息和用户操作，了解用户在不同页面间的跳转路径和行为，发现产品流程中的问题或优化点。
   * **数据统计**：统计不同环境、版本下的用户行为数据，评估产品在不同条件下的使用情况，为产品迭代提供数据支持。

   ### 代码


   ```

   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>User Information</title>
   </head>
   <body>
       <h1>User Information</h1>
       <button onclick="sendUserInfo()">Send User Info</button>
       <script>
           function sendUserInfo() {
               const userAgent = navigator.userAgent;
               const screenWidth = window.screen.width;
               const screenHeight = window.screen.height;
               const osVersion = navigator.platform;
               const browserVersion = navigator.appVersion;

               const userInfo = {
                   userAgent: userAgent,
                   screenWidth: screenWidth,
                   screenHeight: screenHeight,
                   osVersion: osVersion,
                   browserVersion: browserVersion
               };

               fetch('/api/user-info', {
                   method: 'POST',
                   headers: {
                       'Content-Type': 'application/json'
                   },
                   body: JSON.stringify(userInfo)
               })
              .then(response => response.json())
              .then(data => {
                   console.log(data);
               })
              .catch(error => {
                   console.error('Error:', error);
               });
           }
       </script>
   </body>
   </html>
   5. ```
   ```

## slurm 是啥

Slurm 是一个开源的、高度可扩展的集群管理和作业调度系统，广泛应用于高性能计算（HPC）环境，主要用于将作业分配到·集群里面。

以下是其详细信息：

### 一、主要功能

* **作业调度**：
  * Slurm 负责将用户提交的作业（如计算任务、模拟任务、数据分析任务等）分配到集群中的节点上。它会根据资源的可用性、作业的优先级、资源需求（如 CPU 核心数、内存、GPU 等）和调度策略（如先来先服务、公平共享、优先队列等），将作业调度到最合适的节点上运行。
  * 例如，一个用户提交了一个需要大量 CPU 核心和内存的科学计算任务，Slurm 会检查集群中各个节点的资源使用情况，将该任务分配到有足够资源的节点上，避免资源冲突和不合理的分配。
* **资源管理**：
  * 管理集群中的计算资源，包括节点、CPU、内存、GPU、存储等。它可以将整个集群的资源进行分区，不同分区可以有不同的资源特性和使用规则。
  * 比如，可以将集群划分为开发分区、测试分区和生产分区，不同分区的资源分配和访问权限不同，开发分区可能资源较少且优先级较低，生产分区则有更多的资源且为关键任务预留。
  * 它还可以对资源进行监控，实时掌握资源的使用情况，包括哪些节点处于空闲状态、哪些节点正在使用以及使用的资源量等信息。
